Después de varias pruebas descubrimos que el comportamiento de \texttt{SchedMistery} tiene el compartamiento de un \emph{multilevel feedback-queue}. Los parametros pasados son los quantums de las colas en orden de mayor a menos prioridad y tiene por defecto una cola de quantum 1 que es la de mayor prioridad.
\newline Detallamos los atributos privados y publicos de la clase \texttt{SchedNoMistery} donde replicamos el comportamiento de \texttt{SchedMistery}
Atributos privados:
\begin{itemize}
	\item \texttt{vd}: Es un vector que tiene las colas de prioridad en orden, la de mayor prioridad en el 0 y la de menor al final.
	\item \texttt{def\_quantum}: Tiene el quantum de cada una de las colas en vq. La cola en el subíndice i de vq tiene su respectivo quantum en el subíndice i de def\_quantum. 
	\item \texttt{unblock\_to}: Un vector hay un subíndice para cada proceso que tenga el procesador. Cuando un proceso se bloquea guarda en el subíndice pid la prioridad que le toca al desbloquearse. Esto funciona ya que los id de procesos empiezan en 0 y aumentan de a uno a medida que llegan.
	\item \texttt{quantum}: El quantum que le queda a el proceso que esta corriendo.
	\item \texttt{n}: La  cantidad de colas que tiene el scheduler.
	\item \texttt{cur\_pri}: La prioridad de la proceso que se esta corriendo
\end{itemize}

La clase tiene una función privada, \texttt{int next()}, que se encarga de devolver el \emph{pid} del siguiente proceso a ejecutar, buscado, desde la cola de mayor prioridad hasta la de menor, la primera cola vacia donde remueve el primer procesos, reinicia el \emph{quantum} y actualiza \emph{cur\_pri}. En caso de que todas las colas esten vacias devuelve el \emph{pid} de la tarea \emph{idle}.

Además posee los siguientes métodos públicos:
\begin{itemize}
	\item \texttt{SchedNoMistery(vector<int> argn)}: El constructor lee los quantum de las colas pasados como parámetros y los coloca en orden en def\_quantum y genera una cola vacia  para cada cola en vq, para así poder acceder más tarde. Además inicializa cur\_pri con 0, quantum como 1 y n como la cantidad de colas.
	\item \texttt{void load(int pid)}: Carga el proceso identificado por \texttt{pid} en la cola de mayor prioridad. 
	\item \texttt{void unblock(int pid)}: Agrega el proceso con id \texttt{pid} en la cola de prioridad indicada por el contenido del subíndice pid de \texttt{unblock\_to}.
	\item \texttt{int tick(int cpu, const enum Motivo m)}: Tiene tres casos según el motivo con el que se la haya llamado:
	\begin{enumerate}
		\item \texttt{Caso EXIT}: Simplemente llamamos a \texttt{next()} para que corra el siguiente proceso.
		\item \texttt{Caso BLOCK}: Guardo en \texttt{unblock\_to} en la posición del id del proceso que se corre, la prioridad actual menos uno. Después se llama a \texttt{next()} para que pueda correr el siguiete proceso.
		\item \texttt{TICK}: Pueden pasar varias cosas:
		\begin{enumerate}
			\item La tarea actual es \emph{idle}, en cuyo caso solo queda llamar a \texttt{next} y devolver su resultado.
			\item La tarea actual no es \emph{idle} pero se acabó su \emph{quantum}, por lo que hay que encolarla en la siguiente cola con menor prioridad y llamamos a \texttt{next}.
			\item La tarea actual ni es \emph{idle} ni terminó su \emph{quantum}, así que debe seguir ejecutando pero reducimos en 1 la cantidad de ciclos restantes.
		\end{enumerate}
	\end{enumerate}
\end{itemize}